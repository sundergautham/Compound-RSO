//#include <Rcpp.h>
#include <RcppArmadillo.h>
using namespace Rcpp;
using namespace arma;

// [[Rcpp::depends(RcppArmadillo)]]
// [[Rcpp::plugins(cpp11)]]
//' function to create a row of the design matrix of a specified model order
//' @description function to create a row of the design matrix of a specified model order
//' @param x a vector or row matrix of the settings to generate the design matrix for
//' @param model_order a string indicating the order of the regression model. "linear","quadratic" (Main Effects+Quadratic Effects), "2FI" (Main Effects + TwoFactor Interactions),"full", "non_standard"- for a user defined model order order
//' @param C_dtype a string vector indicating the data type of the experimental factors in the design either "cont"(continuous) or "cat"(categorical)
//' @param me_index vector of index of Main Effects to be included in the design for model_order "non_standard"
//' @param qe_index vector index of Quadratic Effects to be included in the design for model_order "non_standard"
//' @param two_fi_index_ list of index of Two Factor Interactions to be included in the design for model_order "non_standard"
//' @return a row of the design matrix for the specified factor levels and  model_order
//'  @examples
//'   f_x(x,model_order="full",C_dtype, me_index=c(),qe_index=c(),two_fi_index=c(),cubic_index=c(),quatric_index=c())
//' @export
// [[Rcpp::export]]
arma::rowvec f_x_cpp(arma::rowvec x,std::string model_order,StringVector C_dtype, IntegerVector me_index= IntegerVector::create(),IntegerVector qe_index= IntegerVector::create(), Nullable<List> two_fi_index_ = R_NilValue){
  arma::rowvec fx_prime={1};
  if(model_order=="linear"){
    fx_prime= join_rows(fx_prime,x);
  }
  else if(model_order=="2FI"){
    fx_prime= join_rows(fx_prime,x);
    int l=x.n_elem;
    for(int i=0; i<l-1; ++i){
      for(int j=(i+1); j<l; ++j){
        arma::rowvec temp={x(i)*x(j)};
        fx_prime=join_rows(fx_prime,temp);
      }
    }
  }
  else if(model_order=="full"){
    fx_prime= join_rows(fx_prime,x);
    //Rcout << "Done with ME" << "\n";
    int l=x.n_elem;
    for(int i=0; i<l-1; ++i){
      for(int j=(i+1); j<l; ++j){
        //Rcout << "Value of i and j" << i << j<<"\n";
        arma::rowvec temp={x(i)*x(j)};
        fx_prime=join_rows(fx_prime,temp);
      }
    }
    //Rcout << "Done with 2FI" << "\n";
    for(int i=0; i<l; ++i){
      if(C_dtype(i)=="cont"){
        //Rcout << "Value of i and j" << i<<"\n";
        arma::rowvec temp={x(i)*x(i)};
        fx_prime=join_rows(fx_prime,temp);
      }
    }
    //Rcout << "Done with QE" << "\n";
  }
  else if(model_order=="quad"){
    fx_prime= join_rows(fx_prime,x);
    int l=x.n_elem;
    for(int i=0; i<l-1; ++i){
      if(C_dtype(i)=="cont"){
        arma::rowvec temp={x(i)*x(i)};
        fx_prime=join_rows(fx_prime,temp);
      }
    }
  }
  else if(model_order=="non_standard"){
    if(me_index.size()>0){
      //Rcout << "Entered me condition" << "\n";
      for(IntegerVector::iterator i = me_index.begin(); i !=  me_index.end(); ++i){
        arma::rowvec temp={x((*i))};
        fx_prime=join_rows(fx_prime,temp);
      }
      //Rcout << "Done with me_index" << "\n";
    }
    if (two_fi_index_.isNotNull()){
      //Rcout << "Entered twofi condition" << "\n";
      Rcpp::List two_fi_index(two_fi_index_);
      for(List::iterator i = two_fi_index.begin(); i !=  two_fi_index.end(); ++i){
        IntegerVector temp=*i;
        temp=temp;
        arma::rowvec temp2={x(temp(0))*x(temp(1))};
        fx_prime=join_rows(fx_prime,temp2);
      }
      //Rcout << "Done with twofi index" << "\n";
    }
    if(qe_index.size()>0){
      //Rcout << "Entered me condition" << "\n";
      for(IntegerVector::iterator i = qe_index.begin(); i !=  qe_index.end(); ++i){
        arma::rowvec temp={x((*i))*x((*i))};
        fx_prime=join_rows(fx_prime,temp);
      }
      //Rcout << "Done with qe index" << "\n";
    }
    //for(i in cubic_index){
    //  fx_prime=c(fx_prime,x[i]**3)
    //}
    //for(i in quatric_index){
    //  fx_prime=c(fx_prime,x[i]**4)
    //}
  }
  //fx_prime=matrix(fx_prime,nrow=1)
  return(fx_prime);
}

// [[Rcpp::depends(RcppArmadillo)]]
// [[Rcpp::plugins(cpp11)]]
//' function for rank 2 inverse to update the inverse of X'X matrix for each coordinate exchange iteration
//' @param x the row vector with the new coordinate value
//' @param x_i the current row vector that needs to be exchanged
//' @param D Current (X'X)inv matrix
//' @return A matrix with the updated (X'X)inv if the exhange leads to a non singular X else a character string "Singular"
//'  @examples
//'   rank2_inverse(x,x_i,D)
//' @export
// [[Rcpp::export]]
arma::mat rank2_inverse_cpp(arma::rowvec x, arma::rowvec x_i, arma::mat D){
  arma::mat U=join_rows(x.t(),x_i.t());
  arma::mat V=join_cols(x,-x_i);
  arma::mat I_2;
  I_2.eye( 2,2 );
  arma::mat r2=I_2+V*D*U;
  //rank 2 update is performed only if the exhchange leads to a non--singular matrix
  if(rcond(r2)>1e-8){
    arma::mat D_new=D-D*U*inv(r2)*V*D;
    if(rcond(D_new)>1e-15){
      return(D_new);
    }
    else{
      //Rcout << "The matrix is singular with condition number"<< rcond(D_new) << "\n";
      return(arma::mat());
    }
  }else{
    //Rcout << "The matrix is singuar with condition number"<< rcond(r2) << "\n";
    return(arma::mat());
  }
}

// [[Rcpp::depends(RcppArmadillo)]]
// [[Rcpp::plugins(cpp11)]]
//' an internal function that computes the intermediate steps in D-optimal designs
//' @description an internal function that computes the intermediate steps in computing the change in determinant value for each coordinate exchange in the construction of D-optimal designs
//' @param x_i a row of the design matrix
//' @param x_j a row of the design matrix
//' @param D current X'X inverse matrix
//' @return a matrix
//' @export
// [[Rcpp::export]]
double v_x_cpp(arma::colvec x_i, arma::colvec x_j, arma::mat D){
  double v=(x_i.t()*D*x_j).eval()(0,0);
  //Rcout<<"Value of v"<<(x_i.t()*D*x_j).eval()(0,0)<<"\n";
  return(v);
}

// [[Rcpp::depends(RcppArmadillo)]]
// [[Rcpp::plugins(cpp11)]]
//' an internal function to compute the change in determinant value for a coordinate exhange in a D-optimal design
//' @description an internal function to compute the change in determinant value for a coordinate exhange in a D-optimal design
//' @param x the row vector with the new coordinate value
//' @param x_i the current row vector that needs to be exchanged
//' @param D current X'X inverse values
//' @export
// [[Rcpp::export]]
double delta_D_cpp(arma::rowvec x, arma::rowvec x_i,arma::mat D){
  double vx=v_x_cpp(x.t(),x.t(),D);
  double v_x_xi=v_x_cpp(x.t(),x_i.t(),D);
  double vi=v_x_cpp(x_i.t(),x_i.t(),D);
  double del=1+(vx-vi)+(std::pow(v_x_xi,2)-vx*vi);
  return(del);
}

// [[Rcpp::depends(RcppArmadillo)]]
// [[Rcpp::plugins(cpp11)]]
//' function for constructing a Bayesian D-optimal design using coordinate exchange
//' @param x settings matrix for the design
//' @param x_matrix design matrix of the specified order
//' @param C list of candidate space for each experimental factor in the design
//' @param model_order a string indicating the order of the regression model. "linear","quadratic" (Main Effects+Quadratic Effects), "2FI" (Main Effects + TwoFactor Interactions),"full", "non_standard"- for a user defined model order order
//' @param C_dtype a string vector indicating the data type of the experimental factors in the design either "cont"(continuous) or "cat"(categorical)
//' @param freeze_rows the rows of the matrix to freeze while augmenting, 0 when type is "non_augment"
//' @param me_index vector of index of Main Effects to be included in the design for model_order "non_standard"
//' @param qe_index vector of index of Quadratic Effects to be included in the design for model_order "non_standard"
//' @param two_fi_index list of index of Two Factor Interactions to be included in the design for model_order "non_standard"
//' @param type a string indicating the type of design augmentation. "non_augment" or "augment" (augment an existing deisgn)
//' @param design a string indicating the type of design constructed. "Non-Bayesian" or "Bayesian" optimal design. The major difference is in how signularity of the matrix is evaluated. In a Bayesian optimal design X'X+K(prior variance matrix) is checked for singularity
//' @param telescoping a boolean value taking TRUE or FALSE. Telescoping reduces the candidate factors the local region of the optimum design
//' @param K a diagonal matrix specifying the prior variance for Bayesian D-optimal design. By default set to 0.001 for potential terms and 0 for primary terms.
//' @description function for constructing a Bayesian D-optimal design using coordinate exchange
//' @return a list of
//'  \itemize{
//'        \item x_matrix- a Bayesian D-optimal design matrix of the specified order
//'        \item optimal_value- Optimal value of the objective value of the Bayesian D-optimal design
//'        \item x- a matrix with factor levels of the Bayesian D-optimal design
//'        }
//'  @examples
//'  \dontrun{
//'   coor_exch_D_Bayes(x,x_matrix,C,model_order,C_dtype,freeze_rows = freeze_rows,me_index=c(),qe_index=c(),two_fi_index=c(),cubic_index = c(),quatric_index = c(),type="non_augment",telescoping=FALSE,K)
//'  }
//'  @export
// [[Rcpp::export]]
List coor_exch_D_Bayes(arma::mat x,arma::mat x_matrix, List C, std::string model_order,
                       StringVector C_dtype, int freeze_rows,
                       arma::mat K,
                       IntegerVector me_index,IntegerVector qe_index, List two_fi_index,
                       std::string type="non_augment",std::string design="Bayesian",
                       bool telescoping=false){
  Rcout<<"Executing Cpp code for D-optimal Designs"<<"\n";
  arma::mat x_start=x;
  //int p=x_matrix.n_cols;
  int p_x=x.n_cols;
  //computes the inverse of X_primeX
  arma::mat D= arma::inv(x_matrix.t()*x_matrix+K);
  double M= arma::det(x_matrix.t()*x_matrix+K);
  int n=x_matrix.n_rows;
  if(type=="non_augment"){
    freeze_rows=0;
  }
  arma::vec v_ij(n-freeze_rows);
  int indx=0;
  for(int i=freeze_rows;i<n;++i){
    v_ij[indx]=v_x_cpp(x_matrix.row(i).t(),x_matrix.row(i).t(),D);
    indx=indx+1;
  }
  IntegerVector sort_indx=as<IntegerVector>(wrap(arma::sort_index(v_ij,"descend")));
  sort_indx=sort_indx+freeze_rows;
  //Rcout << "Sorted Index" << sort_indx << "\n";
  //saves a copy of D
  arma::mat D_local=D;
  arma::mat x_matrix_local=x_matrix;

  //epsilon for monitoring convergence
  double epsilon=1;

  //Current score
  double current=std::log(M);

  Rcout << "Current score" << current << "\n";
  int count_convergence=0;
  double prev;
  arma::mat x_best;
  //double local_val;
  double M_local;
  NumericVector det_val;
  while(epsilon>1e-6){
    //Rcout<< "Entered while loop"<<"\n";
    count_convergence=count_convergence+1;
    //at the end of one complete exchange of x_matrix_local, the updated  matrix is stored
    x_matrix=x_matrix_local;
    prev=current;
    x_best=x;
    //Rcout<< "Starting coordinate exchange loops"<<"\n";
    for(IntegerVector::iterator m = sort_indx.begin(); m != sort_indx.end(); ++m){
      int i=*m;
      //Rcout<< "Starting coordinate exchange loops"<<i<<"\n";
      for(int j=0;j<p_x;++j){
        NumericVector candidate_points;
        if(telescoping==true){
          double point=x_start(i,j);
          double start=std::max(-1.0,point-0.09);
          double end=std::min(1.0,point+0.09);
          double size_telescoping=std::round(((end-start)/0.01) +1.0);
          //Rcout<<size_telescoping<<"\n";
          size_telescoping=(int)size_telescoping;
          int index=0;
          NumericVector candidate_points_local (size_telescoping);
          for(int l=0; l<size_telescoping; ++l){
            candidate_points_local[index]=start+l*0.01;
            index=index+1;
          }
          candidate_points=candidate_points_local;
          //Rcout<<"telescoping is true"<< "\t"<< start<<"\t" <<end <<"\t" <<size_telescoping<<"\t"<< candidate_points<<"\n";
        }else{
          candidate_points=C[j];
          //Rcout<<"Candidate points"<<candidate_points<<"\n";
        }
        det_val=NumericVector(candidate_points.size());
        for(int k =0; k< candidate_points.size(); ++k){
          //Rcout << "Executing row, col, candidate"<< i<<j<<k<<"\n";
          arma::rowvec x_expl;
          arma::mat D_new;
          arma::rowvec x_local=x.row(i);
          //point exchange
          x_local(j)=candidate_points[k];
          x_expl=f_x_cpp(x_local,model_order,C_dtype,me_index,qe_index,two_fi_index);
          D_new=rank2_inverse_cpp(x_expl,x_matrix_local.row(i),D_local);
          //Rcout << "x_local"<<x_matrix_local.row(i)<<"\n";
          //check if singular
          if(D_new.n_cols!=0){
            //Rcout << "Values of M update"<<M<<"\t"<<delta_D_cpp(x_expl,x_matrix_local.row(i),D_local)<<"\n";
            double delta_i=delta_D_cpp(x_expl,x_matrix_local.row(i),D_local);
            M_local=M*delta_i;
            //Rcout<<"Value of i and j"<< i<< "\t"<<j<<"\t"<<candidate_points[k]<<"\n";
            //Rcout<<"local_val"<<std::pow((M_local/dopt),(1.0/p))<<"\t"<<unifopt/unif_disc_local<<"\t"<<unif_disc_local<<M_local<<"\n";
            if(M_local>0){
              det_val[k]=delta_i;
            }else{
              det_val[k]=R_NegInf;
            }
          }else{
            det_val[k]=R_NegInf;
          }
        }
        //Rcout<< "Done with computing the detval"<<det_val<<"\n";
        //det_val=round(det_val,8)
        LogicalVector l_inf=is_infinite(det_val);
        //LogicalVector l_inf={true};
        LogicalVector l_nan=is_nan(det_val);
        if(is_true(any(l_nan))){
          Rcout << "There's nan is det_val" << det_val << "\n";
          stop("Error: NAN value encountered");
        }
        //if all of de_val is not NA
        if(is_false(all(l_inf))){
          int ind=which_max(det_val);
          //Rcout<<"Making the exchange"<<ind<<"\n";
          //make the swap only if the delta is greater than 0
          x(i,j)=candidate_points[ind];
          arma::rowvec x_expl=f_x_cpp(x.row(i),model_order,C_dtype,me_index,qe_index,two_fi_index);
          M=M*det_val[ind];//delta_D_cpp(x_expl,x_matrix_local.row(i),D_local);
          D_local=rank2_inverse_cpp(x_expl,x_matrix_local.row(i),D_local);
          x_matrix_local.row(i)=x_expl;
        }
      }
    }
    //stop("Executed properly the i loop once");
    //print(paste("Ueff", Unif_eff))
    current=std::log(M);
    Rcout << "obj values is" << current<< "\n";
    //print(paste("D eff",D_eff))
    //print(paste("updated objective:",current))
    //calculates epsilon
    epsilon=current-prev;
    //print(paste("prev=",prev))
    //print(epsilon[1])
    Rcout << "Change in objective function" << epsilon << "\n";
    //if(current>1){
    //print(w)
    //#print((M_local/dopt)**(1/p))
    //#print((iopt/I_val))
    //# }
    //#D_eff=det(t(x_matrix_local)%*%x_matrix_local)/dopt
    //#print(D_eff)
    indx=0;
    for(int i=freeze_rows;i<n;++i){
      v_ij[indx]=v_x_cpp(x_matrix.row(i).t(),x_matrix.row(i).t(),D);
      indx=indx+1;
    }

    sort_indx=arma::sort_index(v_ij,"descend");
    sort_indx=sort_indx+freeze_rows;
    //Rcout << "Sorted Index" << sort_indx << "\n";
  }
  Rcout << "Number of iterations to convergence is:"<<count_convergence<<"\n";
  //return(list(x_matrix,prev,x_best,deff_best,Unif_best))
  return(List::create(x_matrix,prev,x_best));
}

// [[Rcpp::depends(RcppArmadillo)]]
// [[Rcpp::plugins(cpp11)]]
//' function for constructing an I-optimal design using coordinate exchange
//' @param x settings matrix of the design
//' @param x_matrix design matrix of the specified order including the intercept
//' @param C list of candidate space for each experimental factor in the design
//' @param model_order a string indicating the order of the regression model. "linear","quadratic" (Main Effects+Quadratic Effects), "2FI" (Main Effects + TwoFactor Interactions),"full", "non_standard"- for a user defined model order order
//' @param C_dtype a string vector indicating the data type of the experimental factors in the design either "cont"(continuous) or "cat"(categorical)
//' @param type a string indicating the type of design augmentation. "non_augment" or "augment" (augment an existing deisgn)
//' @param W Moment matrix computed for a given lambda
//' @param freeze_rows the rows of the matrix to freeze while augmenting, 0 when type is "non_augment"
//' @param me_index vector of index of Main Effects to be included in the design for model_order "non_standard"
//' @param qe_index vector index of Quadratic Effects to be included in the design for model_order "non_standard"
//' @param two_fi_index list of index of Two Factor Interactions to be included in the design for model_order "non_standard"
//' @param telescoping a boolean value taking TRUE or FALSE. Telescoping reduces the candidate factors the local region of the optimum design
//' @description function for constructing an I-optimal design using coordinate exchange
//' @return a list of
//'  \itemize{
//'        \item Iopt_design- I-optimal design matrix of the specified order including the intercept from the random starts
//'        \item Iopt_obj- The value of the I-optimal objective value
//'        \item Iopt_x- a matrix with factor levels of the I-optimal design
//'        }
//'  @examples
//'   coor_exch_I_augment(x,x_matrix,C,model_order,C_dtype, W, freeze_rows=0,type="non_augment",me_index=c(),qe_index=c(),two_fi_index=c(),telescoping=FALSE)
//' @export
// [[Rcpp::export]]
List coor_exch_I_augment(arma::mat x,arma::mat x_matrix, List C, std::string model_order,
                         StringVector C_dtype, arma::mat W,int freeze_rows,
                         IntegerVector me_index,IntegerVector qe_index, List two_fi_index,
                         std::string type="augment",bool telescoping=false){
  Rcout<<"Executing Cpp code for I-optimal Designs"<<"\n";
  arma::mat x_start=x;
  int p_x=x.n_cols;
  //computes the inverse of X_primeX
  arma::mat D= arma::inv(x_matrix.t()*x_matrix);
  int n=x_matrix.n_rows;
  //saves a copy of D
  arma::mat D_local=D;
  arma::mat x_matrix_local=x_matrix;

  //epsilon for monitoring convergence
  double epsilon=1;

  //Current score
  double current=arma::trace(D_local*W);
  Rcout << "Current score" << current << "\n";
  int count_convergence=0;
  double prev;
  arma::mat x_best;
  //double M_local;
  NumericVector det_val;
  while(epsilon>1e-15){
    count_convergence=count_convergence+1;
    //at the end of one complete exchange of x_matrix_local, the updated  matrix is stored
    x_matrix=x_matrix_local;
    prev=current;
    x_best=x;
    for(int i=freeze_rows;i<n;++i){
      for(int j=0;j<p_x;++j){
        //current value of trace
        double tr_current=arma::trace(D_local*W);
        //D_val_current=M
        NumericVector candidate_points;
        if(telescoping==true){
          double point=x_start(i,j);
          double start=std::max(-1.0,point-0.09);
          double end=std::min(1.0,point+0.09);
          double size_telescoping=std::round(((end-start)/0.01) +1.0);
          //Rcout<<size_telescoping<<"\n";
          size_telescoping=(int)size_telescoping;
          int index=0;
          NumericVector candidate_points_local (size_telescoping);
          for(int l=0; l<size_telescoping; ++l){
            candidate_points_local[index]=start+l*0.01;
            index=index+1;
          }
          candidate_points=candidate_points_local;
          //Rcout<<"telescoping is true"<< "\t"<< start<<"\t" <<end <<"\t" <<size_telescoping<<"\t"<< candidate_points<<"\n";
        }else{
          candidate_points=C[j];
          //Rcout<<"Candidate points"<<candidate_points<<"\n";
        }
        det_val=NumericVector(candidate_points.size());
        for(int k =0; k< candidate_points.size(); ++k){
          //Rcout << "Executing row, col, candidate"<< i<<j<<k<<"\n";
          arma::rowvec x_local=x.row(i);
          //point exchange
          x_local(j)=candidate_points[k];
          arma::mat D_new;
          arma::rowvec x_expl;
          x_expl=f_x_cpp(x_local,model_order,C_dtype,me_index,qe_index,two_fi_index);
          D_new=rank2_inverse_cpp(x_expl,x_matrix_local.row(i),D_local);
          //check if singular
          if(D_new.n_cols!=0){
            det_val[k]=tr_current-arma::trace(D_new*W);
          }else{
            det_val[k]=R_NegInf;
          }
        }
        //Rcout<< "Done with computing the detval"<<det_val<<"\n";
        //det_val=round(det_val,8)
        LogicalVector l_inf=is_infinite(det_val);
        //LogicalVector l_inf={true};
        LogicalVector l_nan=is_nan(det_val);
        if(is_true(any(l_nan))){
          Rcout << "There's nan is det_val" << det_val << "\n";
          stop("Error: NAN encountered when constructing designs");
        }
        //if all of de_val is not NA
        if(is_false(all(l_inf))){
          int ind=which_max(det_val);
          //make the swap only if the delta is greater than 0
          if(det_val[ind]>0){
            x(i,j)=candidate_points[ind];
            arma::rowvec x_expl=f_x_cpp(x.row(i),model_order,C_dtype,me_index,qe_index,two_fi_index);
            D_local=rank2_inverse_cpp(x_expl,x_matrix_local.row(i),D_local);
            x_matrix_local.row(i)=x_expl;
          }
        }
      }
    }
    current=arma::trace(D_local*W);
    Rcout << "obj values is" << current<< "\n";
    //calculates epsilon
    epsilon=prev-current;
    Rcout << "Change in objective function" << epsilon << "\n";
  }
  Rcout << "Number of iterations to convergence is:"<<count_convergence<<"\n";
  return(List::create(x_matrix,prev,x_best));
}

// [[Rcpp::depends(RcppArmadillo)]]
// [[Rcpp::plugins(cpp11)]]
//' function for constructing the Adaptive-RSO designs using coordinate exchange
//' @description function for constructing the Adaptove-RSO designs using coordinate exchange. The Adaptive-RSO designs is the compound optimal design between Bayesian D-optimal design and I-optimal design
//' @param x settings matrix of the design
//' @param x_matrix design matrix of the specified order including the intercept
//' @param C list of candidate points for all factors in the design
//' @param model_order string indicating linear,quadratic (Main Effects+Quadratic Effects), 2FI (Main Effects + TwoFactor Interactions),full, non_standard for a user defined order
//' @param me_index vector of index of Main Effects to be included in the I-optimal design for model_order "non_standard"
//' @param qe_index vector index of Quadratic Effects to be included in the I-optimal design for model_order "non_standard"
//' @param two_fi_index list of index of Two Factor Interactions to be included in the I-optimal design for model_order "non_standard"
//' @param C_dtype data type of the factors in the design either "cont"(continuous) or "cat"(categorical)
//' @param W Moment matrix computed for a given lambda
//' @param freeze_rows the rows of the matrix to freeze while augmenting, 0 when type is "non_augment"
//' @param x_matrix_Dopt the D-optimal design matrix
//' @param x_matrix_Iopt the I-optimal design matrix
//' @param w a numeric value of weight that is used to compute the compound optimal design
//' @param K a diagonal matrix specifying the prior variance in Bayesian D-optimal design set to 0.001 for potential terms and 0 for primary terms
//' @param D_opt_type Type of D-optimal design Bayesian or regular D-optimal design
//' @param me_index_daug vector of index of Main Effects to be included in the D-optimal design for model_order "non_standard"
//' @param qe_index_daug vector index of Quadratic Effects to be included in the D-optimal design for model_order "non_standard"
//' @param two_fi_index_daug list of index of Two Factor Interactions to be included in the D-optimal design for model_order "non_standard"
//' @param type "non_augment" or "augment" (augment an existing deisgn)
//' @param telescoping a boolean value taking TRUE or FALSE. Telescoping reduces the candidate factors the local region of the optimum design
//'   \itemize{
//'         \item x_matrix- the design matrix for a given model order
//'         \item opt_val- the compound optimal objective value
//'         \item x_best- matrix of factor levels for the optimal design
//'         \item deff_best- the d-efficiency of the optimal design
//'         \item ieff_best- the uniform efficiency of the optimal design
//'         }
//' @examples
//' \dontrun{
//' coor_exch_compound(x,x_matrix,C,model_order,me_index = c(),qe_index = c(),two_fi_index = c(),C_dtype, W, freeze_rows=0,x_matrix_Dopt,x_matrix_Iopt,w,K=0,D_opt_type="Bayesian",me_index_daug, qe_index_daug,two_fi_index_daug,telescoping=FALSE)
//' }
//' @export
// [[Rcpp::export]]
List coor_exch_compound(arma::mat x,arma::mat x_matrix, List C, std::string model_order,
                        StringVector C_dtype, arma::mat W,int freeze_rows,
                        arma::mat x_matrix_Dopt,
                        arma::mat x_matrix_Iopt, double w, arma::mat K,
                        IntegerVector me_index,IntegerVector qe_index, List two_fi_index,
                        IntegerVector me_index_daug,IntegerVector qe_index_daug, List two_fi_index_daug,
                        std::string D_opt_type="Bayesian",bool telescoping=false){
  Rcout<<"Executing Cpp code for Exploration Exploitation Designs"<<"\n";
  arma::mat x_start=x;
  int p=x_matrix.n_cols;
  int p_x=x.n_cols;
  //computes the inverse of X_primeX
  arma::mat D= arma::inv(x_matrix.t()*x_matrix+K);
  int n=x_matrix.n_rows;
  //saves a copy of D
  arma::mat D_local=D;
  double dopt=arma::det(x_matrix_Dopt.t()*x_matrix_Dopt + K);
  double iopt=arma::trace(arma::inv(x_matrix_Iopt.t()*x_matrix_Iopt)*W);
  arma::mat x_matrix_local=x_matrix;

  //epsilon for monitoring convergence
  double epsilon=1;

  //Current L-optimality score
  double M=det(x_matrix_local.t()*x_matrix_local + K);
  double D_eff=std::pow((M/dopt),(1.0/p));

  int p_I=1+me_index.length()+qe_index.length()+two_fi_index.length();
  arma::mat x_matrix_local_I(n,p_I);
  arma::mat D_local_I;
  double I_val;
  if(D_opt_type=="Bayesian"){
    for(int i=0; i<n;++i){
      arma::rowvec x_expl=f_x_cpp(x.row(i),"non_standard",C_dtype,me_index,qe_index,two_fi_index);
      x_matrix_local_I.row(i)=x_expl;
    }
    D_local_I=arma::inv(x_matrix_local_I.t()*x_matrix_local_I);
    I_val=arma::trace(D_local_I*W);
  }else{
    I_val=arma::trace(D_local*W);
  }
  //Rcout<<"Dimension of x_matrix_local_I"<<x_matrix_local_I.n_rows<<x_matrix_local_I.n_cols<<"\n";
  double I_eff=(iopt/I_val);
  double current=w*D_eff+(1.0-w)*I_eff;
  Rcout << "Ieff" << I_eff << "\n";
  Rcout << "Deff" << D_eff << "\n";
  Rcout << "Current compromise score" << current << "\n";
  int count_convergence=0;
  double prev;
  double Ieff_best;
  double deff_best;
  arma::mat x_best;
  double  I_val_local;
  double local_val;
  double M_local;
  NumericVector det_val;
  while(epsilon>1e-3){
    //Rcout<< "Entered while loop"<<"\n";
    count_convergence=count_convergence+1;
    //at the end of one complete exhchange of x_matrix_local, the updated  matrix is stored
    x_matrix=x_matrix_local;
    prev=current;
    Ieff_best=I_eff;
    deff_best=D_eff;
    x_best=x;
    //Rcout<< "Starting coordinate exchange loops"<<"\n";
    for(int i=freeze_rows;i<n;++i){
      //print(paste("exchange of row number:", i))
      for(int j=0;j<p_x;++j){
        //print(paste("exchange of col number:", j))
        //current value of trace
        //I_val_current=sum(diag(D_local%*%W))
        //D_val_current=M
        NumericVector candidate_points;
        if(telescoping==true){
          double point=x_start(i,j);
          double start=std::max(-1.0,point-0.09);
          double end=std::min(1.0,point+0.09);
          double size_telescoping=std::round(((end-start)/0.01) +1.0);
          //Rcout<<size_telescoping<<"\n";
          size_telescoping=(int)size_telescoping;
          int index=0;
          NumericVector candidate_points_local (size_telescoping);
          for(int l=0; l<size_telescoping; ++l){
            candidate_points_local[index]=start+l*0.01;
            index=index+1;
          }
          candidate_points=candidate_points_local;
          //Rcout<<"telescoping is true"<< "\t"<< start<<"\t" <<end <<"\t" <<size_telescoping<<"\t"<< candidate_points<<"\n";
        }else{
          candidate_points=C[j];
          //Rcout<<"Candidate points"<<candidate_points<<"\n";
        }
        det_val=NumericVector(candidate_points.size());
        for(int k =0; k< candidate_points.size(); ++k){
          //Rcout << "Executing row, col, candidate"<< i<<j<<k<<"\n";
          arma::rowvec x_local=x.row(i);
          //point exchange
          x_local(j)=candidate_points[k];
          arma::mat D_new;
          arma::mat D_new_I;
          arma::rowvec x_expl_I;
          arma::rowvec x_expl;
          if(D_opt_type=="Bayesian"){
            x_expl_I=f_x_cpp(x_local,"non_standard",C_dtype,me_index,qe_index,two_fi_index);
            D_new_I=rank2_inverse_cpp(x_expl_I,x_matrix_local_I.row(i),D_local_I);

            x_expl=f_x_cpp(x_local,"non_standard",C_dtype,me_index_daug,qe_index_daug,two_fi_index_daug);
            D_new=rank2_inverse_cpp(x_expl,x_matrix_local.row(i),D_local);
          }else{
            x_expl=f_x_cpp(x_local,"non_standard",C_dtype,me_index_daug,qe_index_daug,two_fi_index_daug);
            D_new=rank2_inverse_cpp(x_expl,x_matrix_local.row(i),D_local);
            D_new_I.eye( 2,2 );
          }
          //Rcout << "x_local"<<x_matrix_local.row(i)<<"\n";
          //check if singular
          if(D_new.n_cols!=0 && D_new_I.n_cols!=0){
            //Rcout << "Values of M update"<<M<<"\t"<<delta_D_cpp(x_expl,x_matrix_local.row(i),D_local)<<"\n";
            M_local=M*delta_D_cpp(x_expl,x_matrix_local.row(i),D_local);
            if(D_opt_type=="Bayesian"){
              I_val_local=arma::trace(D_new_I*W);
            }else{
              I_val_local=arma::trace(D_new*W);
            }
            //Rcout<<"Value of i and j"<< i<< "\t"<<j<<"\t"<<candidate_points[k]<<"\n";
            //Rcout<<"local_val"<<std::pow((M_local/dopt),(1.0/p))<<"\t"<<unifopt/unif_disc_local<<"\t"<<unif_disc_local<<M_local<<"\n";
            if(M_local>0){
              local_val=w*(std::pow((M_local/dopt),(1.0/p)))+(1.0-w)*(iopt/I_val_local);
              det_val[k]=local_val;
            }else{
              det_val[k]=R_NegInf;
            }
          }else{
            det_val[k]=R_NegInf;
          }
        }
        //Rcout<< "Done with computing the detval"<<det_val<<"\n";
        //det_val=round(det_val,8)
        LogicalVector l_inf=is_infinite(det_val);
        //LogicalVector l_inf={true};
        LogicalVector l_nan=is_nan(det_val);
        if(is_true(any(l_nan))){
          Rcout << "There's nan is det_val" << det_val << "\n";
          stop("Error: NAN encountered");
        }
        //if(is_true(any(l_inf))){
        //  Rcout << "Atleast one singular exchange in row and col" <<  i << j << "det_val"<< det_val << "\n";
        //  //print(paste("change in objective function at iteration",count_convergence))
        //  //print(det_val)
        //}
        //det_val=ifelse(abs(det_val)==Inf,NaN,det_val)
        //print(det_val)
        //if(!any(is.na(det_val)) & !any(abs(det_val)==Inf)){
        //if all of de_val is not NA
        if(is_false(all(l_inf))){
          int ind=which_max(det_val);
          //Rcout<<"Making the exchange"<<ind<<"\n";
          //print(paste("max=",ind))
          //make the swap only if the delta is greater than 0
          if(det_val[ind]-current>0){
            x(i,j)=candidate_points[ind];
            if(D_opt_type=="Bayesian"){
              arma::rowvec x_expl=f_x_cpp(x.row(i),"non_standard",C_dtype,me_index_daug,qe_index_daug,two_fi_index_daug);
              M=M*delta_D_cpp(x_expl,x_matrix_local.row(i),D_local);
              D_local=rank2_inverse_cpp(x_expl,x_matrix_local.row(i),D_local);
              x_matrix_local.row(i)=x_expl;

              arma::rowvec x_expl_I=f_x_cpp(x.row(i),"non_standard",C_dtype,me_index,qe_index,two_fi_index);
              D_local_I=rank2_inverse_cpp(x_expl_I,x_matrix_local_I.row(i),D_local_I);
              x_matrix_local_I.row(i)=x_expl_I;
              I_val=arma::trace(D_local_I*W);

              I_eff=(iopt/I_val);
              D_eff=std::pow((M/dopt),(1.0/p));
              current=w*D_eff+(1.0-w)*I_eff;
            }else{
              arma::rowvec x_expl=f_x_cpp(x.row(i),"non_standard",C_dtype,me_index_daug,qe_index_daug,two_fi_index_daug);
              M=M*delta_D_cpp(x_expl,x_matrix_local.row(i),D_local);
              D_local=rank2_inverse_cpp(x_expl,x_matrix_local.row(i),D_local);
              x_matrix_local.row(i)=x_expl;

              I_val=arma::trace(D_local*W);
              I_eff=(iopt/I_val);
              D_eff=std::pow((M/dopt),(1.0/p));
              current=w*D_eff+(1.0-w)*I_eff;
            }
          }
        }//else{
        //return(list(x_matrix,100000,x_best))
        //print(x_matrix_local)
        //print(j)
        //print(i)
        //Rcout << "All singular exchanges in row and col" <<  i << j << "det_val"<< det_val << "\n";
        //}
      }
      //print(paste("det of inf matrix:",determinant(t(x_matrix_local)%*%x_matrix_local)$modulus[1]))
      //current=sum(diag(D_local%*%W))
    }
    //stop("Executed properly the i loop once");
    //print(paste("Ueff", Unif_eff))
    Rcout << "D_eff, Ieff and obj values are" << D_eff<< I_eff<< current<< "\n";
    //calculates epsilon
    epsilon=current-prev;
    Rcout << "Change in objective function" << epsilon << "\n";
  }
  Rcout << "Number of iterations to convergence is:"<<count_convergence<<"\n";
  return(List::create(x_matrix,prev,x_best,deff_best,Ieff_best));
  //return(List::create());
}

// [[Rcpp::depends(RcppArmadillo)]]
//' computes the W2 uniform discrepancy criteria update for each coordinate exchange
//' @param X settings matrix of the design
//' @param i row being updated
//' @param j column being updated
//' @param xij_new new factor level at the i,j index
//' @param disc_matrix discrepancy matrix for W2 discrepancy measure
//' @param update  boolean value indicating whether to update or create a new discrepancy matrix
//' @param rescale boolean value indicating whether to rescale the design matrix to a (0,1) experimental region
//' @return returns a discrepancy matrix
//' @description computes the W2 uniform discrepancy criteria update for each coordinate exchange
//' @examples
//' \dontrun{
//' discW2_update(X,i,j,xij_new,disc_matrix,update=FALSE)
//' }
//' @export
// [[Rcpp::export]]
arma::mat discW2_update_cpp(arma::mat X,bool update, arma::mat disc_matrix, bool rescale=true, int i=0L, int j=0L, double xij_new=0L){
  int rows=X.n_rows;
  int cols=X.n_cols;
  if(update==false){
    //change domain to [0,1]
    if(rescale==true){
      X=(X+1)/2;
    }
    arma::mat disc_matrix(rows,rows);
    disc_matrix.zeros();
    for(int i=0; i<rows; ++i){
      for(int k=i; k< rows; ++k){
        arma::colvec temp=1.5-arma::abs(vectorise(X.row(i))-vectorise(X.row(k)))+arma::pow(arma::abs(vectorise(X.row(i))-vectorise(X.row(k))),2);
        double prod=1;
        for(int j=0; j<cols;++j){
          //Rcout << "The value of temp j : " << temp(j) << "\n";
          prod=prod*temp(j);
        }
        //Rcout << "The value of prod : " << prod << "\n";
        disc_matrix(i,k)=prod;
        disc_matrix(k,i)=prod;
      }
    }
    //disc_matrix[lower.tri(disc_matrix)]=t(disc_matrix)[lower.tri(disc_matrix)]
    return(disc_matrix);
  }
  else{
    arma::mat X_new=X;
    X_new(i,j)=xij_new;
    //change domain to [0,1]
    if(rescale==true){
      X=(X+1)/2;
      X_new=(X_new+1)/2;
    }
    double xij_new=X_new(i,j);
    //arma::mat disc_matrix_ = as<arma::mat>(disc_matrix);
    arma::mat disc_matrix_new=disc_matrix;
    //Rcout << "Value of i:"<< i << "\n";
    //Rcout << "Value of j:"<< j << "\n";
    for(int col_up=0; col_up<rows; ++col_up){
      //Rcout << "Value of col_up:"<< col_up << "\n";
      double up_value=(1.5-std::abs(xij_new-X_new(col_up,j))+std::pow(std::abs(xij_new-X_new(col_up,j)),2))/(1.5-std::abs(X(i,j)-X(col_up,j))+std::pow(std::abs(X(i,j)-X(col_up,j)),2));
      disc_matrix_new(i,col_up)=disc_matrix(i,col_up)*up_value;
      disc_matrix_new(col_up,i)=disc_matrix(col_up,i)*up_value;
    }
    return(disc_matrix_new);
  }
}


// [[Rcpp::depends(RcppArmadillo)]]
//' computes the M2 uniform discrepancy criteria update for each exchange
//' @param X settings matrix of the design
//' @param i row being updated
//' @param j column being updated
//' @param xij_new new factor level at the i,j index
//' @param disc_matrix discrepancy matrix for M2 discrepancy measure
//' @param disc_vector discrepancy vector for M2 discrepancy measure
//' @param update  boolean value indicating whether to update or create a new discrepancy matrix
//' @param rescale boolean value indicating whether to rescale the design matrix to a (0,1) experimental region
//' @return returns a discrepancy matrix
//' @description computes the M2 uniform discrepancy criteria update for each exchange
//' @examples
//' \dontrun{
//' discM2_update(X,i,j,xij_new,disc_matrix,disc_vector,update=FALSE,rescale=TRUE)
//' }
//' @export
// [[Rcpp::export]]
List discM2_update_cpp(arma::mat X,bool update,arma::mat disc_matrix, arma::colvec disc_vector,bool rescale=true,int i=0L, int j=0L, double xij_new=0L){
  //pass a zero matrix and vector for the case update=False
  int rows=X.n_rows;
  int cols=X.n_cols;
  if(update==false){
    //change domain to [0,1]
    if(rescale==true){
      X=(X+1)/2;
    }
    arma::mat disc_matrix(rows,rows);
    disc_matrix.zeros();
    arma::colvec disc_vector(rows);
    disc_vector.zeros();
    //Rcout << "Starting for loop"<< "\n";
    for(int i=0; i<rows; ++i){
      arma::colvec temp1=5.0/3.0-(1.0/4.0)*arma::abs(vectorise(X.row(i))-0.5)-(1.0/4.0)*arma::pow(arma::abs(vectorise(X.row(i))-0.5),2);
      double prod=1;
      for(int j=0; j<cols;++j){
        prod=prod*temp1(j);
      }
      disc_vector(i)=prod;
      for(int k=i; k< rows; ++k){
        //Rcout << "The value of k : " << k << "\n";
        //Rcout << "The value of i : " << i << "\n";
        //Rcout << "The value of X i : " << X.row(i) << "\n";
        //Rcout << "The value of temp : " << 3/2-abs(vectorise(X.row(i))-vectorise(X.row(k)))+pow(abs(vectorise(X.row(i))-vectorise(X.row(k))),2) << "\n";
        arma::colvec temp=15.0/8.0-(1.0/4.0)*arma::abs(vectorise(X.row(i))-0.5)-(1.0/4.0)*arma::abs(vectorise(X.row(k))-0.5)-0.75*arma::abs(vectorise(X.row(i))-vectorise(X.row(k)))+0.5*arma::pow(arma::abs(vectorise(X.row(i))-vectorise(X.row(k))),2);
        double prod=1;
        for(int j=0; j<cols;++j){
          //Rcout << "The value of temp j : " << temp(j) << "\n";
          prod=prod*temp(j);
        }
        //Rcout << "The value of prod : " << prod << "\n";
        disc_matrix(i,k)=prod;
        disc_matrix(k,i)=prod;
      }
    }
    //disc_matrix[lower.tri(disc_matrix)]=t(disc_matrix)[lower.tri(disc_matrix)]
    return(List::create(disc_matrix, disc_vector));
  }
  else{
    //Rcout << "Entered the Else condition"<< "\n";
    arma::mat X_new=X;
    X_new(i,j)=xij_new;
    //change domain to [0,1]
    if(rescale==true){
      X=(X+1)/2;
      X_new=(X_new+1)/2;
    }
    double xij_new=X_new(i,j);
    //arma::mat disc_matrix_ = disc_matrix;
    arma::mat disc_matrix_new=disc_matrix;
    //arma::colvec disc_vector_ = disc_vector;
    arma::colvec disc_vector_new=disc_vector;
    disc_vector_new(i)=disc_vector_new(i)*((5.0/3.0)-0.25*std::abs(xij_new-0.5)-0.25*std::pow(std::abs(xij_new-0.5),2))/((5.0/3.0)-0.25*std::abs(X(i,j)-0.5)-0.25*std::pow(std::abs(X(i,j)-0.5),2));
    for(int col_up=0; col_up<rows; ++col_up){
      //Rcout << "Value of col_up:"<< col_up << "\n";
      double up_value=(15.0/8.0-(0.25)*std::abs(xij_new-0.5)-(0.25)*std::abs(X_new(col_up,j)-0.5)-0.75*std::abs(xij_new-X_new(col_up,j))+0.5*std::pow(std::abs(xij_new-X_new(col_up,j)),2))/(15.0/8.0-(0.25)*std::abs(X(i,j)-0.5)-(0.25)*std::abs(X(col_up,j)-0.5)-0.75*std::abs(X(i,j)-X(col_up,j))+0.5*std::pow(std::abs(X(i,j)-X(col_up,j)),2));
      disc_matrix_new(i,col_up)=disc_matrix(i,col_up)*up_value;
      disc_matrix_new(col_up,i)=disc_matrix(col_up,i)*up_value;
    }
    return(List::create(disc_matrix_new, disc_vector_new));
  }
}

// [[Rcpp::depends(RcppArmadillo)]]
// [[Rcpp::plugins(cpp11)]]
//' function for computing the compound uniform design using coordinate exchange
//' @description function for computing the compound uniform design using coordinate exchange
//' @param x settings matrix of the design
//' @param x_matrix a starting design matrix of the specified order including the intercept
//' @param C_dtype data type of the factors in the design either "cont"(continuous) or "cat"(categorical)
//' @param C list of candidate points for all factors in the design
//' @param model_order string indicating linear,quadratic (Main Effects+Quadratic Effects), 2FI (Main Effects + TwoFactor Interactions),full, non_standard for a user defined order
//' @param freeze_rows the rows of the matrix to freeze while augmenting
//' @param x_matrix_Dopt the D-optimal design matrix
//' @param x_unifopt the settings matrix of the Uniform-optimal design
//' @param unif_crit uniform criterion one of "MD2" (default) or "WD2"
//' @param w weight for computing the compound optimal design
//' @param K a diagonal matrix of prior variance for the Bayesian D optimal design
//' @param me_index_daug vector of index of Main Effects to be included in the D-optimal design for model_order "non_standard"
//' @param qe_index_daug vector index of Quadratic Effects to be included in the D-optimal design for model_order "non_standard"
//' @param two_fi_index_daug list of index of Two Factor Interactions to be included in the D-optimal design for model_order "non_standard"
//' @param telescoping a boolean value indicating whether telescoping (fine tuning) the current design or not
//' @return a list of x_matrix,prev,x_best,deff_best,Unif_best
//'   \itemize{
//'         \item x_matrix- the design matrix for a given model order
//'         \item opt_val- the compound optimal objective value
//'         \item x_best- matrix of factor levels for the optimal design
//'         \item deff_best- the d-efficiency of the optimal design
//'         \item Unif_best- the uniform efficiency of the optimal design
//'         }
//' @examples
//' \dontrun{
//' coor_exch_compound_unif(x,x_matrix,C,model_order,C_dtype,freeze_rows=0,x_matrix_Dopt,x_unifopt,unif_crit="MD2",w,K=0,me_index_daug, qe_index_daug,two_fi_index_daug,telescoping=FALSE)
//' }
//' @export
// [[Rcpp::export]]
List coor_exch_compound_unif(arma::mat x,arma::mat x_matrix, List C, std::string model_order,
                             StringVector C_dtype, int freeze_rows,
                             arma::mat x_matrix_Dopt,
                             arma::mat x_unifopt, std::string unif_crit, double w, arma::mat K,
                             IntegerVector me_index_daug,IntegerVector qe_index_daug, List two_fi_index_daug,
                             bool telescoping=false){
  Rcout<<"Executing Cpp code with discrepancy criteria"<<unif_crit<<"\n";
  arma::mat x_start=x;
  int p=x_matrix.n_cols;
  int p_x=x.n_cols;
  //computes the inverse of X_primeX
  arma::mat D= inv(x_matrix.t()*x_matrix+K);
  int n=x_matrix.n_rows;
  //saves a copy of D
  arma::mat D_local=D;
  double dopt=det(x_matrix_Dopt.t()*x_matrix_Dopt + K);
  arma::mat disc_matrix;
  arma::colvec disc_vector;
  arma::mat I_2;
  I_2.eye( 2,2 );
  double unifopt;
  double unif_disc;
  arma::colvec I_1={1};
  if(unif_crit=="WD2"){
    disc_matrix=discW2_update_cpp(x_unifopt,false, I_2, false);
    double disc_val=-std::pow((4.0/3.0),p_x)+(1.0/std::pow(n,2))*arma::accu(disc_matrix);
    unifopt=std::sqrt(disc_val);
  }else if(unif_crit=="MD2"){
    List unifopt_=discM2_update_cpp(x_unifopt,false,I_2,I_1,false);
    disc_matrix=Rcpp::as<arma::mat>(unifopt_[0]);
    disc_vector=Rcpp::as<arma::colvec>(unifopt_[1]);
    unifopt=std::sqrt(std::pow((19.0/12.0),p_x)-(2.0/n)*arma::accu(disc_vector)+(1.0/std::pow(n,2))*arma::accu(disc_matrix));
  }
  arma::mat x_matrix_local=x_matrix;
  arma::mat disc_matrix_local=disc_matrix;
  arma::mat disc_vector_local=disc_vector;
  //epsilon for monitoring convergence
  double epsilon=1;

  //Current L-optimality score
  double M=det(x_matrix_local.t()*x_matrix_local + K);
  double D_eff=std::pow((M/dopt),(1.0/p));
  if(unif_crit=="WD2"){
    disc_matrix=discW2_update_cpp(x,false, I_2, true);
    double disc_val=-std::pow((4.0/3.0),p_x)+(1.0/std::pow(n,2))*arma::accu(disc_matrix);
    unif_disc=std::sqrt(disc_val);
  }else if(unif_crit=="MD2"){
    List unifopt_=discM2_update_cpp(x,false,I_2,I_1,true);
    disc_matrix=Rcpp::as<arma::mat>(unifopt_[0]);
    disc_vector=Rcpp::as<arma::colvec>(unifopt_[1]);
    unif_disc=std::sqrt(std::pow((19.0/12.0),p_x)-(2.0/n)*arma::accu(disc_vector)+(1.0/std::pow(n,2))*arma::accu(disc_matrix));
  }
  double Unif_eff=(unifopt/unif_disc);
  double current=w*D_eff+(1.0-w)*Unif_eff;
  Rcout << "Ueff" << unifopt<< unif_disc << Unif_eff << "\n";
  Rcout << "Deff" << dopt<< M<< D_eff << "\n";
  Rcout << "Current compromise score" << current << "\n";
  int count_convergence=0;
  double prev;
  double Unif_best;
  double deff_best;
  arma::mat x_best;
  double  unif_disc_local;
  double local_val;
  double M_local;
  NumericVector det_val;
  while(epsilon>1e-3){
    //Rcout<< "Entered while loop"<<"\n";
    count_convergence=count_convergence+1;
    //at the end of one complete exhchange of x_matrix_local, the updated  matrix is stored
    x_matrix=x_matrix_local;
    prev=current;
    Unif_best=Unif_eff;
    deff_best=D_eff;
    x_best=x;
    //Rcout<< "Starting coordinate exchange loops"<<"\n";
    for(int i=freeze_rows;i<n;++i){
      for(int j=0;j<p_x;++j){
        //current value of trace
        //I_val_current=sum(diag(D_local%*%W))
        //D_val_current=M
        NumericVector candidate_points;
        if(telescoping==true){
          double point=x_start(i,j);
          double start=std::max(-1.0,point-0.09);
          double end=std::min(1.0,point+0.09);
          double size_telescoping=std::round(((end-start)/0.01) +1.0);
          //Rcout<<size_telescoping<<"\n";
          size_telescoping=(int)size_telescoping;
          int index=0;
          NumericVector candidate_points_local (size_telescoping);
          for(int l=0; l<size_telescoping; ++l){
            candidate_points_local[index]=start+l*0.01;
            index=index+1;
          }
          candidate_points=candidate_points_local;
          //Rcout<<"telescoping is true"<< "\t"<< start<<"\t" <<end <<"\t" <<size_telescoping<<"\t"<< candidate_points<<"\n";
        }else{
          candidate_points=C[j];
          //Rcout<<"Candidate points"<<candidate_points<<"\n";
        }
        det_val=NumericVector(candidate_points.size());
        for(int k =0; k< candidate_points.size(); ++k){
          //arma::mat x_unif_local=x
          //x_unif_local[i,j]=*k
          //disc_matrix_local=disc_matrix
          //Rcout << "Executing row, col, candidate"<< i<<j<<k<<"\n";
          arma::rowvec x_local=x.row(i);
          //point exchange
          x_local(j)=candidate_points[k];
          //Rcout << "Executed point exchange"<<"\n";
          //f_x_cpp(arma::rowvec x,std::string model_order,StringVector C_dtype, IntegerVector me_index= IntegerVector::create(),IntegerVector qe_index= IntegerVector::create(), Nullable<List> two_fi_index_ = R_NilValue)
          arma::rowvec x_expl=f_x_cpp(x_local,"non_standard",C_dtype,me_index_daug,qe_index_daug,two_fi_index_daug);
          //Rcout << "x_expl"<<x_expl<<"\n";
          arma::mat D_new=rank2_inverse_cpp(x_expl,x_matrix_local.row(i),D_local);
          //Rcout << "x_local"<<x_matrix_local.row(i)<<"\n";
          //check if singular
          if(D_new.n_cols!=0){
            //M_local=det(t(x_new)%*%x_new)#M*delta_D(x_expl,x_matrix_local[i,],D_local)
            //Rcout << "Values of M update"<<M<<"\t"<<delta_D_cpp(x_expl,x_matrix_local.row(i),D_local)<<"\n";
            M_local=M*delta_D_cpp(x_expl,x_matrix_local.row(i),D_local);
            if(unif_crit=="WD2"){
              disc_matrix_local=discW2_update_cpp(x,true,disc_matrix,true,i,j,candidate_points[k]);
              double disc_val=-std::pow((4.0/3.0),p_x)+(1.0/std::pow(n,2))*arma::accu(disc_matrix_local);
              unif_disc_local=std::sqrt(disc_val);
            }else if(unif_crit=="MD2"){
              List unifopt_=discM2_update_cpp(x,true,disc_matrix,disc_vector,true,i,j,candidate_points[k]);
              disc_matrix_local=Rcpp::as<arma::mat>(unifopt_[0]);
              disc_vector_local=Rcpp::as<arma::colvec>(unifopt_[1]);
              unif_disc_local=std::sqrt(std::pow((19.0/12.0),p_x)-(2.0/n)*arma::accu(disc_vector_local)+(1.0/std::pow(n,2))*arma::accu(disc_matrix_local));
            }
            //Rcout<<"Value of i and j"<< i<< "\t"<<j<<"\t"<<candidate_points[k]<<"\n";
            //Rcout<<"local_val"<<std::pow((M_local/dopt),(1.0/p))<<"\t"<<unifopt/unif_disc_local<<"\t"<<unif_disc_local<<M_local<<"\n";
            if(M_local>0){
              local_val=w*(std::pow((M_local/dopt),(1.0/p)))+(1-w)*(unifopt/unif_disc_local);
              det_val[k]=local_val;
            }else{
              det_val[k]=R_NegInf;
            }
          }else{
            det_val[k]=R_NegInf;
          }
        }
        //Rcout<< "Done with computing the detval"<<det_val<<"\n";
        //det_val=round(det_val,8)
        LogicalVector l_inf=is_infinite(det_val);
        //LogicalVector l_inf={true};
        LogicalVector l_nan=is_nan(det_val);
        if(is_true(any(l_nan))){
          Rcout << "There's nan is det_val" << det_val << "\n";
          stop("Error: NaN encountered");
        }
        //if(is_true(any(l_inf))){
        //  Rcout << "Atleast one singular exchange in row and col" <<  i << j << "det_val"<< det_val << "\n";
        //  //print(paste("change in objective function at iteration",count_convergence))
        //  //print(det_val)
        //}
        //det_val=ifelse(abs(det_val)==Inf,NaN,det_val)
        //print(det_val)
        //if(!any(is.na(det_val)) & !any(abs(det_val)==Inf)){
        //if all of de_val is not NA
        if(is_false(all(l_inf))){
          int ind=which_max(det_val);
          //Rcout<<"Making the exchange"<<ind<<"\n";
          //print(paste("max=",ind))
          //make the swap only if the delta is greater than 0
          if(det_val[ind]-current>0){
            if(unif_crit=="WD2"){
              disc_matrix=discW2_update_cpp(x,true,disc_matrix,true,i,j,candidate_points[ind]);
              double disc_val=-std::pow((4.0/3.0),p_x)+(1.0/std::pow(n,2))*arma::accu(disc_matrix);
              unif_disc=std::sqrt(disc_val);
            }else if(unif_crit=="MD2"){
              List unifopt_=discM2_update_cpp(x,true,disc_matrix,disc_vector,true,i,j,candidate_points[ind]);
              disc_matrix=Rcpp::as<arma::mat>(unifopt_[0]);
              disc_vector=Rcpp::as<arma::colvec>(unifopt_[1]);
              unif_disc=std::sqrt(std::pow((19.0/12.0),p_x)-(2.0/n)*arma::accu(disc_vector)+(1.0/std::pow(n,2))*arma::accu(disc_matrix));
            }
            x(i,j)=candidate_points[ind];
            arma::rowvec x_expl=f_x_cpp(x.row(i),"non_standard",C_dtype,me_index_daug,qe_index_daug,two_fi_index_daug);
            M=M*delta_D_cpp(x_expl,x_matrix_local.row(i),D_local);
            D_local=rank2_inverse_cpp(x_expl,x_matrix_local.row(i),D_local);
            x_matrix_local.row(i)=x_expl;
            Unif_eff=(unifopt/unif_disc);
            D_eff=std::pow((M/dopt),(1.0/p));
            current=w*(D_eff)+(1-w)*Unif_eff;
          }
        }
      }
      //print(paste("det of inf matrix:",determinant(t(x_matrix_local)%*%x_matrix_local)$modulus[1]))
      //current=sum(diag(D_local%*%W))
    }
    //stop("Executed properly the i loop once");
    //print(paste("Ueff", Unif_eff))
    Rcout << "D_eff, Ueff and obj values are" << D_eff<< "\t"<<Unif_eff<< "\t"<< current<< "\n";
    //print(paste("D eff",D_eff))
    //print(paste("updated objective:",current))
    //calculates epsilon
    epsilon=current-prev;
    //print(paste("prev=",prev))
    //print(epsilon[1])
    Rcout << "Change in objective function" << epsilon << "\n";
    //if(current>1){
    //print(w)
    //#print((M_local/dopt)**(1/p))
    //#print((iopt/I_val))
    //# }
    //#D_eff=det(t(x_matrix_local)%*%x_matrix_local)/dopt
    //#print(D_eff)
  }
  Rcout << "Number of iterations to convergence is:"<<count_convergence<<"\n";
  //print(paste("Number of iterations to convergence is:",count_convergence))
  //return(list(x_matrix,prev,x_best,deff_best,Unif_best))
  return(List::create(x_matrix,prev,x_best,deff_best,Unif_best));
  //return(List::create());
}
