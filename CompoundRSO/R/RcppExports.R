# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' function to create a row of the design matrix of a specified model order
#' @description function to create a row of the design matrix of a specified model order
#' @param x a vector or row matrix of the settings to generate the design matrix for
#' @param model_order a string indicating the order of the regression model. "linear","quadratic" (Main Effects+Quadratic Effects), "2FI" (Main Effects + TwoFactor Interactions),"full", "non_standard"- for a user defined model order order
#' @param C_dtype a string vector indicating the data type of the experimental factors in the design either "cont"(continuous) or "cat"(categorical)
#' @param me_index vector of index of Main Effects to be included in the design for model_order "non_standard"
#' @param qe_index vector index of Quadratic Effects to be included in the design for model_order "non_standard"
#' @param two_fi_index_ list of index of Two Factor Interactions to be included in the design for model_order "non_standard"
#' @return a row of the design matrix for the specified factor levels and  model_order
#'  @examples
#'   f_x(x,model_order="full",C_dtype, me_index=c(),qe_index=c(),two_fi_index=c(),cubic_index=c(),quatric_index=c())
#' @export
f_x_cpp <- function(x, model_order, C_dtype, me_index = as.integer( c()), qe_index = as.integer( c()), two_fi_index_ = NULL) {
    .Call(`_CompoundRSO_f_x_cpp`, x, model_order, C_dtype, me_index, qe_index, two_fi_index_)
}

#' function for rank 2 inverse to update the inverse of X'X matrix for each coordinate exchange iteration
#' @param x the row vector with the new coordinate value
#' @param x_i the current row vector that needs to be exchanged
#' @param D Current (X'X)inv matrix
#' @return A matrix with the updated (X'X)inv if the exhange leads to a non singular X else a character string "Singular"
#'  @examples
#'   rank2_inverse(x,x_i,D)
#' @export
rank2_inverse_cpp <- function(x, x_i, D) {
    .Call(`_CompoundRSO_rank2_inverse_cpp`, x, x_i, D)
}

#' an internal function that computes the intermediate steps in D-optimal designs
#' @description an internal function that computes the intermediate steps in computing the change in determinant value for each coordinate exchange in the construction of D-optimal designs
#' @param x_i a row of the design matrix
#' @param x_j a row of the design matrix
#' @param D current X'X inverse matrix
#' @return a matrix
#' @export
v_x_cpp <- function(x_i, x_j, D) {
    .Call(`_CompoundRSO_v_x_cpp`, x_i, x_j, D)
}

#' an internal function to compute the change in determinant value for a coordinate exhange in a D-optimal design
#' @description an internal function to compute the change in determinant value for a coordinate exhange in a D-optimal design
#' @param x the row vector with the new coordinate value
#' @param x_i the current row vector that needs to be exchanged
#' @param D current X'X inverse values
#' @export
delta_D_cpp <- function(x, x_i, D) {
    .Call(`_CompoundRSO_delta_D_cpp`, x, x_i, D)
}

#' function for constructing a Bayesian D-optimal design using coordinate exchange
#' @param x settings matrix for the design
#' @param x_matrix design matrix of the specified order
#' @param C list of candidate space for each experimental factor in the design
#' @param model_order a string indicating the order of the regression model. "linear","quadratic" (Main Effects+Quadratic Effects), "2FI" (Main Effects + TwoFactor Interactions),"full", "non_standard"- for a user defined model order order
#' @param C_dtype a string vector indicating the data type of the experimental factors in the design either "cont"(continuous) or "cat"(categorical)
#' @param freeze_rows the rows of the matrix to freeze while augmenting, 0 when type is "non_augment"
#' @param me_index vector of index of Main Effects to be included in the design for model_order "non_standard"
#' @param qe_index vector of index of Quadratic Effects to be included in the design for model_order "non_standard"
#' @param two_fi_index list of index of Two Factor Interactions to be included in the design for model_order "non_standard"
#' @param type a string indicating the type of design augmentation. "non_augment" or "augment" (augment an existing deisgn)
#' @param design a string indicating the type of design constructed. "Non-Bayesian" or "Bayesian" optimal design. The major difference is in how signularity of the matrix is evaluated. In a Bayesian optimal design X'X+K(prior variance matrix) is checked for singularity
#' @param telescoping a boolean value taking TRUE or FALSE. Telescoping reduces the candidate factors the local region of the optimum design
#' @param K a diagonal matrix specifying the prior variance for Bayesian D-optimal design. By default set to 0.001 for potential terms and 0 for primary terms.
#' @description function for constructing a Bayesian D-optimal design using coordinate exchange
#' @return a list of
#'  \itemize{
#'        \item x_matrix- a Bayesian D-optimal design matrix of the specified order
#'        \item optimal_value- Optimal value of the objective value of the Bayesian D-optimal design
#'        \item x- a matrix with factor levels of the Bayesian D-optimal design
#'        }
#'  @examples
#'  \dontrun{
#'   coor_exch_D_Bayes(x,x_matrix,C,model_order,C_dtype,freeze_rows = freeze_rows,me_index=c(),qe_index=c(),two_fi_index=c(),cubic_index = c(),quatric_index = c(),type="non_augment",telescoping=FALSE,K)
#'  }
#'  @export
coor_exch_D_Bayes <- function(x, x_matrix, C, model_order, C_dtype, freeze_rows, K, me_index, qe_index, two_fi_index, type = "non_augment", design = "Bayesian", telescoping = FALSE) {
    .Call(`_CompoundRSO_coor_exch_D_Bayes`, x, x_matrix, C, model_order, C_dtype, freeze_rows, K, me_index, qe_index, two_fi_index, type, design, telescoping)
}

#' function for constructing an I-optimal design using coordinate exchange
#' @param x settings matrix of the design
#' @param x_matrix design matrix of the specified order including the intercept
#' @param C list of candidate space for each experimental factor in the design
#' @param model_order a string indicating the order of the regression model. "linear","quadratic" (Main Effects+Quadratic Effects), "2FI" (Main Effects + TwoFactor Interactions),"full", "non_standard"- for a user defined model order order
#' @param C_dtype a string vector indicating the data type of the experimental factors in the design either "cont"(continuous) or "cat"(categorical)
#' @param type a string indicating the type of design augmentation. "non_augment" or "augment" (augment an existing deisgn)
#' @param W Moment matrix computed for a given lambda
#' @param freeze_rows the rows of the matrix to freeze while augmenting, 0 when type is "non_augment"
#' @param me_index vector of index of Main Effects to be included in the design for model_order "non_standard"
#' @param qe_index vector index of Quadratic Effects to be included in the design for model_order "non_standard"
#' @param two_fi_index list of index of Two Factor Interactions to be included in the design for model_order "non_standard"
#' @param telescoping a boolean value taking TRUE or FALSE. Telescoping reduces the candidate factors the local region of the optimum design
#' @description function for constructing an I-optimal design using coordinate exchange
#' @return a list of
#'  \itemize{
#'        \item Iopt_design- I-optimal design matrix of the specified order including the intercept from the random starts
#'        \item Iopt_obj- The value of the I-optimal objective value
#'        \item Iopt_x- a matrix with factor levels of the I-optimal design
#'        }
#'  @examples
#'   coor_exch_I_augment(x,x_matrix,C,model_order,C_dtype, W, freeze_rows=0,type="non_augment",me_index=c(),qe_index=c(),two_fi_index=c(),telescoping=FALSE)
#' @export
coor_exch_I_augment <- function(x, x_matrix, C, model_order, C_dtype, W, freeze_rows, me_index, qe_index, two_fi_index, type = "augment", telescoping = FALSE) {
    .Call(`_CompoundRSO_coor_exch_I_augment`, x, x_matrix, C, model_order, C_dtype, W, freeze_rows, me_index, qe_index, two_fi_index, type, telescoping)
}

#' function for constructing the Adaptive-RSO designs using coordinate exchange
#' @description function for constructing the Adaptove-RSO designs using coordinate exchange. The Adaptive-RSO designs is the compound optimal design between Bayesian D-optimal design and I-optimal design
#' @param x settings matrix of the design
#' @param x_matrix design matrix of the specified order including the intercept
#' @param C list of candidate points for all factors in the design
#' @param model_order string indicating linear,quadratic (Main Effects+Quadratic Effects), 2FI (Main Effects + TwoFactor Interactions),full, non_standard for a user defined order
#' @param me_index vector of index of Main Effects to be included in the I-optimal design for model_order "non_standard"
#' @param qe_index vector index of Quadratic Effects to be included in the I-optimal design for model_order "non_standard"
#' @param two_fi_index list of index of Two Factor Interactions to be included in the I-optimal design for model_order "non_standard"
#' @param C_dtype data type of the factors in the design either "cont"(continuous) or "cat"(categorical)
#' @param W Moment matrix computed for a given lambda
#' @param freeze_rows the rows of the matrix to freeze while augmenting, 0 when type is "non_augment"
#' @param x_matrix_Dopt the D-optimal design matrix
#' @param x_matrix_Iopt the I-optimal design matrix
#' @param w a numeric value of weight that is used to compute the compound optimal design
#' @param K a diagonal matrix specifying the prior variance in Bayesian D-optimal design set to 0.001 for potential terms and 0 for primary terms
#' @param D_opt_type Type of D-optimal design Bayesian or regular D-optimal design
#' @param me_index_daug vector of index of Main Effects to be included in the D-optimal design for model_order "non_standard"
#' @param qe_index_daug vector index of Quadratic Effects to be included in the D-optimal design for model_order "non_standard"
#' @param two_fi_index_daug list of index of Two Factor Interactions to be included in the D-optimal design for model_order "non_standard"
#' @param type "non_augment" or "augment" (augment an existing deisgn)
#' @param telescoping a boolean value taking TRUE or FALSE. Telescoping reduces the candidate factors the local region of the optimum design
#'   \itemize{
#'         \item x_matrix- the design matrix for a given model order
#'         \item opt_val- the compound optimal objective value
#'         \item x_best- matrix of factor levels for the optimal design
#'         \item deff_best- the d-efficiency of the optimal design
#'         \item ieff_best- the uniform efficiency of the optimal design
#'         }
#' @examples
#' \dontrun{
#' coor_exch_compound(x,x_matrix,C,model_order,me_index = c(),qe_index = c(),two_fi_index = c(),C_dtype, W, freeze_rows=0,x_matrix_Dopt,x_matrix_Iopt,w,K=0,D_opt_type="Bayesian",me_index_daug, qe_index_daug,two_fi_index_daug,telescoping=FALSE)
#' }
#' @export
coor_exch_compound <- function(x, x_matrix, C, model_order, C_dtype, W, freeze_rows, x_matrix_Dopt, x_matrix_Iopt, w, K, me_index, qe_index, two_fi_index, me_index_daug, qe_index_daug, two_fi_index_daug, D_opt_type = "Bayesian", telescoping = FALSE) {
    .Call(`_CompoundRSO_coor_exch_compound`, x, x_matrix, C, model_order, C_dtype, W, freeze_rows, x_matrix_Dopt, x_matrix_Iopt, w, K, me_index, qe_index, two_fi_index, me_index_daug, qe_index_daug, two_fi_index_daug, D_opt_type, telescoping)
}

#' computes the W2 uniform discrepancy criteria update for each coordinate exchange
#' @param X settings matrix of the design
#' @param i row being updated
#' @param j column being updated
#' @param xij_new new factor level at the i,j index
#' @param disc_matrix discrepancy matrix for W2 discrepancy measure
#' @param update  boolean value indicating whether to update or create a new discrepancy matrix
#' @param rescale boolean value indicating whether to rescale the design matrix to a (0,1) experimental region
#' @return returns a discrepancy matrix
#' @description computes the W2 uniform discrepancy criteria update for each coordinate exchange
#' @examples
#' \dontrun{
#' discW2_update(X,i,j,xij_new,disc_matrix,update=FALSE)
#' }
#' @export
discW2_update_cpp <- function(X, update, disc_matrix, rescale = TRUE, i = 0L, j = 0L, xij_new = 0L) {
    .Call(`_CompoundRSO_discW2_update_cpp`, X, update, disc_matrix, rescale, i, j, xij_new)
}

#' computes the M2 uniform discrepancy criteria update for each exchange
#' @param X settings matrix of the design
#' @param i row being updated
#' @param j column being updated
#' @param xij_new new factor level at the i,j index
#' @param disc_matrix discrepancy matrix for M2 discrepancy measure
#' @param disc_vector discrepancy vector for M2 discrepancy measure
#' @param update  boolean value indicating whether to update or create a new discrepancy matrix
#' @param rescale boolean value indicating whether to rescale the design matrix to a (0,1) experimental region
#' @return returns a discrepancy matrix
#' @description computes the M2 uniform discrepancy criteria update for each exchange
#' @examples
#' \dontrun{
#' discM2_update(X,i,j,xij_new,disc_matrix,disc_vector,update=FALSE,rescale=TRUE)
#' }
#' @export
discM2_update_cpp <- function(X, update, disc_matrix, disc_vector, rescale = TRUE, i = 0L, j = 0L, xij_new = 0L) {
    .Call(`_CompoundRSO_discM2_update_cpp`, X, update, disc_matrix, disc_vector, rescale, i, j, xij_new)
}

#' function for computing the compound uniform design using coordinate exchange
#' @description function for computing the compound uniform design using coordinate exchange
#' @param x settings matrix of the design
#' @param x_matrix a starting design matrix of the specified order including the intercept
#' @param C_dtype data type of the factors in the design either "cont"(continuous) or "cat"(categorical)
#' @param C list of candidate points for all factors in the design
#' @param model_order string indicating linear,quadratic (Main Effects+Quadratic Effects), 2FI (Main Effects + TwoFactor Interactions),full, non_standard for a user defined order
#' @param freeze_rows the rows of the matrix to freeze while augmenting
#' @param x_matrix_Dopt the D-optimal design matrix
#' @param x_unifopt the settings matrix of the Uniform-optimal design
#' @param unif_crit uniform criterion one of "MD2" (default) or "WD2"
#' @param w weight for computing the compound optimal design
#' @param K a diagonal matrix of prior variance for the Bayesian D optimal design
#' @param me_index_daug vector of index of Main Effects to be included in the D-optimal design for model_order "non_standard"
#' @param qe_index_daug vector index of Quadratic Effects to be included in the D-optimal design for model_order "non_standard"
#' @param two_fi_index_daug list of index of Two Factor Interactions to be included in the D-optimal design for model_order "non_standard"
#' @param telescoping a boolean value indicating whether telescoping (fine tuning) the current design or not
#' @return a list of x_matrix,prev,x_best,deff_best,Unif_best
#'   \itemize{
#'         \item x_matrix- the design matrix for a given model order
#'         \item opt_val- the compound optimal objective value
#'         \item x_best- matrix of factor levels for the optimal design
#'         \item deff_best- the d-efficiency of the optimal design
#'         \item Unif_best- the uniform efficiency of the optimal design
#'         }
#' @examples
#' \dontrun{
#' coor_exch_compound_unif(x,x_matrix,C,model_order,C_dtype,freeze_rows=0,x_matrix_Dopt,x_unifopt,unif_crit="MD2",w,K=0,me_index_daug, qe_index_daug,two_fi_index_daug,telescoping=FALSE)
#' }
#' @export
coor_exch_compound_unif <- function(x, x_matrix, C, model_order, C_dtype, freeze_rows, x_matrix_Dopt, x_unifopt, unif_crit, w, K, me_index_daug, qe_index_daug, two_fi_index_daug, telescoping = FALSE) {
    .Call(`_CompoundRSO_coor_exch_compound_unif`, x, x_matrix, C, model_order, C_dtype, freeze_rows, x_matrix_Dopt, x_unifopt, unif_crit, w, K, me_index_daug, qe_index_daug, two_fi_index_daug, telescoping)
}

rcpparma_hello_world <- function() {
    .Call(`_CompoundRSO_rcpparma_hello_world`)
}

rcpparma_outerproduct <- function(x) {
    .Call(`_CompoundRSO_rcpparma_outerproduct`, x)
}

rcpparma_innerproduct <- function(x) {
    .Call(`_CompoundRSO_rcpparma_innerproduct`, x)
}

rcpparma_bothproducts <- function(x) {
    .Call(`_CompoundRSO_rcpparma_bothproducts`, x)
}

